<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/media/a15f2fce4b98b461-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/d0f42c95ff9c5e3c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d0f42c95ff9c5e3c.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-6ef43a8d4a395f49.js" defer=""></script><script src="/_next/static/chunks/framework-73b8966a3c579ab0.js" defer=""></script><script src="/_next/static/chunks/main-a7f38f10aaa61e85.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9e255844138bd61c.js" defer=""></script><script src="/_next/static/chunks/9f96d65d-d5c35cf9956607d4.js" defer=""></script><script src="/_next/static/chunks/668-dca87ae6eadd6810.js" defer=""></script><script src="/_next/static/chunks/903-a1e04c8c265c8956.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bcategory%5D/%5Bslug%5D-62fcc8fc9e36b202.js" defer=""></script><script src="/_next/static/rGSduaPge73_pVAo9USSe/_buildManifest.js" defer=""></script><script src="/_next/static/rGSduaPge73_pVAo9USSe/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="__className_33e7a8"><style data-emotion="css c02091">.css-c02091{max-width:720px;margin:0 auto;padding:120px 0;}</style><div class="css-c02091"><style data-emotion="css 11p9xzi">.css-11p9xzi{font-weight:400;font-size:16px;margin-bottom:10px;color:#3B3B3B;}</style><h1 class="css-11p9xzi">개발 일지</h1><style data-emotion="css d7ne5u">.css-d7ne5u{margin-bottom:40px;font-weight:300;font-size:14px;color:#979797;}</style><div class="css-d7ne5u">2023-07-21</div><style data-emotion="css 19z457s">.css-19z457s{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:100%;line-height:28px;gap:20px;}.css-19z457s img{width:100%;}.css-19z457s h2{font-weight:400;font-size:16px;}.css-19z457s h3{font-weight:400;font-size:16px;}.css-19z457s strong{font-weight:400;}.css-19z457s li{list-style:circle;margin:5px 0 5px 30px;}.css-19z457s li ul{margin:5px 0 0 0;}.css-19z457s hr{margin:50px 0;background-color:#eeeeee;height:1px;border:0;}.css-19z457s pre>pre{border-radius:13px;border:1px solid #e4e2e0;}.css-19z457s .code-in-paragrahs{background:#faf8f5;padding:3px 5px;border-radius:5px;border:1px solid #e4e2e0;}.css-19z457s a{color:#808080;-webkit-text-decoration:none;text-decoration:none;border-bottom:0.1px solid #808080;padding-bottom:0.1px;}</style><div class="css-19z457s"><div node="[object Object]">이 글은 지금까지 개발하면서 배우고 생각했던 내용들을 정리한 글이다. <strong>코드에 접근하는 방식과 문제를 해결하는 방식</strong>을 설명하였지만, 이는 회사마다 사람마다 다를 수도 있다. 나는 아래의 과정들을 거치면서 조금은 발전했다고 느꼈고 다른 사람들에게도 공유하고자 정리해본다. 참고로 새롭게 깨달은 내용들이 생기면 이 글에 계속 업데이트할 예정이다.</div>
<h2>1. 리팩토링과 추상화 그리고 프로덕트 개발자</h2>
<div node="[object Object]">코드를 작성하다 보면 리팩토링에 대한 생각을 자주한다. 그때 스스로에게 이 질문을 던져보자. &#x27;지금도 충분히 괜찮은가?&#x27;, &#x27;리팩토링한다면 어떻게 할까?&#x27; 만약 이 질문에 대한 대답의 시간이 길어진다면 지금이 답일 가능성도 있다. &#x27;현재로서는 최선이다.&#x27; 말이 있지 않은가.</div>
<div node="[object Object]">프로덕트 개발자로 작업하면서 추상화와 관련된 인상적인 경험이 있다.</div>
<div node="[object Object]">만약 무언가를 숨기고 이전 단계로 넘어가는 함수가 있다고 가정해보자.</div>
<pre><pre style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#faf8f5;color:#728fcb;padding:1em;margin:.5em 0;overflow:auto"><code class="language-ts" style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#faf8f5;color:#728fcb"><span class="token" style="color:#728fcb">const</span><span> previous </span><span class="token" style="color:#063289">=</span><span> </span><span class="token" style="color:#b29762">useCallback</span><span class="token" style="color:#b6ad9a">(</span><span class="token" style="color:#728fcb">async</span><span> </span><span class="token" style="color:#b6ad9a">(</span><span class="token" style="color:#b6ad9a">)</span><span> </span><span class="token arrow" style="color:#063289">=&gt;</span><span> </span><span class="token" style="color:#b6ad9a">{</span><span>
</span><span>  </span><span class="token control-flow" style="color:#728fcb">await</span><span> </span><span class="token" style="color:#b29762">hide</span><span class="token" style="color:#b6ad9a">(</span><span class="token" style="color:#b6ad9a">)</span><span class="token" style="color:#b6ad9a">;</span><span>
</span><span>  </span><span class="token" style="color:#b29762">onPrevious</span><span class="token" style="color:#b6ad9a">(</span><span class="token" style="color:#b6ad9a">)</span><span class="token" style="color:#b6ad9a">;</span><span>
</span><span></span><span class="token" style="color:#b6ad9a">}</span><span class="token" style="color:#b6ad9a">,</span><span> </span><span class="token" style="color:#b6ad9a">[</span><span>hide</span><span class="token" style="color:#b6ad9a">,</span><span> onPrevious</span><span class="token" style="color:#b6ad9a">]</span><span class="token" style="color:#b6ad9a">)</span><span class="token" style="color:#b6ad9a">;</span><span>
</span></code></pre></pre>
<div node="[object Object]">hide와 useCallback이 반복되는 상황이라면 useHideCallback 훅을 만들어서 추상화할 수 있지 않을까?</div>
<pre><pre style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#faf8f5;color:#728fcb;padding:1em;margin:.5em 0;overflow:auto"><code class="language-ts" style="font-family:Consolas, Menlo, Monaco, &quot;Andale Mono WT&quot;, &quot;Andale Mono&quot;, &quot;Lucida Console&quot;, &quot;Lucida Sans Typewriter&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Bitstream Vera Sans Mono&quot;, &quot;Liberation Mono&quot;, &quot;Nimbus Mono L&quot;, &quot;Courier New&quot;, Courier, monospace;font-size:14px;line-height:1.375;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;background:#faf8f5;color:#728fcb"><span class="token" style="color:#728fcb">const</span><span> hideAndOnPrevious </span><span class="token" style="color:#063289">=</span><span> </span><span class="token" style="color:#b29762">useHideCallback</span><span class="token" style="color:#b6ad9a">(</span><span>onPrevious</span><span class="token" style="color:#b6ad9a">)</span><span class="token" style="color:#b6ad9a">;</span><span>
</span><span></span><span class="token" style="color:#728fcb">const</span><span> hideAndOnNext </span><span class="token" style="color:#063289">=</span><span> </span><span class="token" style="color:#b29762">useHideCallback</span><span class="token" style="color:#b6ad9a">(</span><span>onNext</span><span class="token" style="color:#b6ad9a">)</span><span class="token" style="color:#b6ad9a">;</span><span>
</span></code></pre></pre>
<div node="[object Object]">4줄의 코드가 1줄이 되었다. 그리고 다른 동작들도 손쉽게 추가할 수 있다. 코드의 양도 줄고 반복도 없어졌으니 좋은건가? 여기서 우리는 이 추상화가 필요한 추상화였는지 생각해볼 필요가 있다. 위 코드를 처음 접하는 개발자는 빠르게 이 코드를 이해할 수 있을까? 나는 추상화를 하기 전 코드가 오히려 흐름을 파악하기 쉽고 직관적이라고 생각한다.</div>
<ul>
<li>Conciseness . 간결함</li>
<li>Conciseness level . 의미 있는 단위의 최소 단위</li>
</ul>
<div node="[object Object]">우리는 코드에서 Conciseness(간결함)를 추구한다. 하지만 짧은 코드를 모두 좋은 코드라고는 볼 수 없다. Conciseness level(의미 있는 단위의 최소 단위) 우리는 이 레벨을 낮춰서 읽기 수월하게 만들어야 한다. 단순히 추상화를 진행한다고 conciseness level이 높은게 아니다. 이 과정은 코드를 단순히 짧게 만드는 것과는 다르다. 추상화 레벨이 높을수록 숨어있는 말과 의미가 많다. 그 숨겨진 의미가 노출되지 않았을 때 실수가 줄고 효율이 높아진다.</div>
<div node="[object Object]">그렇다면 나와 같은 프로덕트 개발자는 어디까지 추상화를 진행해야 할까? 서비스 레벨에서는 자신의 코드를 지우거나 변경하기 쉽게 만드는게 최고다. 위에서 만들었던 useHideCallback 같이 프레임워크인척하면 안된다. 이는 오히려 변경하기 어렵게 만든다.</div>
<div node="[object Object]">서비스 코드는 쉽게 변경되기 때문에 높은 추상화를 요구하지 않고 대체로 불필요하다. 스펙이 바뀔 가능성이 높기 때문에 변하지 않는다고 단언하는건 위험하다. 이러한 이유로 useHideCallback 수준으로 추상화를 진행하지 않아도 괜찮다. 지금은 hide, onPrevious 두 개의 로직이지만 중간에 로그와 같은 로직들이 추가될 가능성이 높기 때문이다.</div>
<div node="[object Object]">반대로 프레임워크 수준은 단언할 수 있어야할 만큼 안정적이고 더 이상 변경될 요지가 없을 만큼 성숙해져야 한다. (e.g., useState, useCallback)</div>
<hr/>
<div node="[object Object]">지금부터는 한 줄씩 짧게 끊어서 글을 이어가려고 한다. 각 줄에 대한 설명을 적을 수도 있었지만 대부분 충분히 전달력 있는 문장이라고 생각했기 때문이다.</div>
<h2>2. 코드에 접근하는 방식</h2>
<div node="[object Object]">Top-down 방식으로 숲을 먼저 본 다음 나무 각각의 관계성을 본다.</div>
<div node="[object Object]">정보가 여러 개 있을 때는 추상화를 진행하며, 의존성을 낮춘다.</div>
<div node="[object Object]">소스 코드에 사용하는 변수, 모듈, 함수 등 각각에 대한 책임을 고민한다.</div>
<div node="[object Object]">읽기 쉬운 코드가 무엇일까에 대하여 고민한다.</div>
<div node="[object Object]">“어떻게”보다는 “무엇&quot;에 더 집중해야 한다.</div>
<ul>
<li>개발뿐만 아니라 설명할 때도 동일하다. 어떤 문제가 있느냐를 생각하고 전달하자.</li>
<li>무엇과 어떻게가 비슷하다면 어떻게로 진행한다. (추상화를 진행하여도 수준이 비슷하다면 꼭 추상화를 할 필요는 없다.)</li>
</ul>
<div node="[object Object]">이미 사용된 솔루션을 존중할 수 있지만, 무조건 신뢰해서는 안 된다.</div>
<ul>
<li>“예전에도 이랬으니까 이번에도 이렇다&quot;라는 근거는 합리적이지 않다.</li>
</ul>
<div node="[object Object]">실수할 여지가 있는 코드는 피한다.</div>
<div node="[object Object]">서비스 간 패키지를 공유하는 것은 패키지 간의 의존성이 생기기 때문에 좋지 않다.</div>
<div node="[object Object]">완전히 종속된 컴포넌트는 파일을 더 만드는 것이 아닌 한 파일 안에서 작성하는 것도 좋다.</div>
<div node="[object Object]">가능한 입력 범위를 예상하고, 그에 따라 적절한 솔루션을 적용하자</div>
<div node="[object Object]">동작 원리를 이해할 수 있어야 한다.</div>
<div node="[object Object]">코드를 통제할 수 있어야 한다.</div>
<div node="[object Object]">작은 부분에 대하여 스스로 확답이 있어야 한다.</div>
<div node="[object Object]">코드가 더럽다고 느껴질 때</div>
<ul>
<li>하나의 함수에서 순서를 정리해보거나 주석, 별도 함수로 나눠보자</li>
<li>줄일 수 있는 조건문을 찾아보자 (중복, 불필요한 반복)</li>
<li>상태를 관리하는 변수가 많은지 찾아보고 리팩토링해보자</li>
<li>전체적인 코드 정리 및 리팩토링에 들어가자</li>
<li>네이밍을 신경 쓰자</li>
<li>inline 할 수 있는 함수가 있는가 살펴보자</li>
</ul>
<div node="[object Object]">코드에 대한 고민</div>
<ul>
<li>다음에 이 코드를 봤을 때 더 빨리 읽고 수정이 가능해야 한다.</li>
</ul>
<hr/>
<h2>3. 문제 해결에 대한 방식</h2>
<div node="[object Object]">큰 문제를 작은 문제로 쪼개서 풀 수 있는 문제로 만들자</div>
<div node="[object Object]">시스템 퍼포먼스의 비용보다 사람 리소스의 비용이 더 크다.</div>
<div node="[object Object]">개발을 진행하다 막히는 부분이 있으면, 혼자 해결할 수 있는 문제인지 아닌지 먼저 파악한다. (네이티브, 서버의 도움이 필요한가)</div>
<div node="[object Object]">무작정 기능 구현에 집중하기보다는 해당 기능의 임팩트와 들어가는 비용을 생각하며 일을 정한다.</div>
<div node="[object Object]">요구사항, 블로킹 정도, 일정에 따라 빠르게 우선순위가 바뀐다.</div>
<div node="[object Object]">적극적으로 의견을 피력하는게 중요하다.</div>
<div node="[object Object]">판단은 논리적인 근거가 필요하다.</div>
<div node="[object Object]">더 나은 엔지니어링 솔루션이 있는지 탐색하고 비교한다.</div>
<div node="[object Object]">논리에 허점이 있을 때 인정하고 시스템 논리에 솔직해지자</div>
<div node="[object Object]">이전에 대화했던 의견에 대하여 확신이 들지 않을 때 이전의 히스토리를 먼저 설명한다.</div>
<ul>
<li>정보의 불확실성을 공유하는 것이기 때문에 첨언을 하여 상대방에게 먼저 인지를 할 수 있도록 한다.</li>
</ul>
<div node="[object Object]">비즈니스 문제를 엔지니어링 문제로 바꿔보자</div>
<div node="[object Object]">운영으로 풀 수 있는걸 테크로 풀지 마라</div>
<div node="[object Object]">진행하기 전 블로커를 먼저 찾고 흐름을 파악하자</div></div></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"title":"개발 일지","date":"2023-07-21"},"content":"\n이 글은 지금까지 개발하면서 배우고 생각했던 내용들을 정리한 글이다. **코드에 접근하는 방식과 문제를 해결하는 방식**을 설명하였지만, 이는 회사마다 사람마다 다를 수도 있다. 나는 아래의 과정들을 거치면서 조금은 발전했다고 느꼈고 다른 사람들에게도 공유하고자 정리해본다. 참고로 새롭게 깨달은 내용들이 생기면 이 글에 계속 업데이트할 예정이다.\n\n## 1. 리팩토링과 추상화 그리고 프로덕트 개발자\n\n코드를 작성하다 보면 리팩토링에 대한 생각을 자주한다. 그때 스스로에게 이 질문을 던져보자. '지금도 충분히 괜찮은가?', '리팩토링한다면 어떻게 할까?' 만약 이 질문에 대한 대답의 시간이 길어진다면 지금이 답일 가능성도 있다. '현재로서는 최선이다.' 말이 있지 않은가.\n\n프로덕트 개발자로 작업하면서 추상화와 관련된 인상적인 경험이 있다.\n\n만약 무언가를 숨기고 이전 단계로 넘어가는 함수가 있다고 가정해보자.\n\n```ts\nconst previous = useCallback(async () =\u003e {\n  await hide();\n  onPrevious();\n}, [hide, onPrevious]);\n```\n\nhide와 useCallback이 반복되는 상황이라면 useHideCallback 훅을 만들어서 추상화할 수 있지 않을까?\n\n```ts\nconst hideAndOnPrevious = useHideCallback(onPrevious);\nconst hideAndOnNext = useHideCallback(onNext);\n```\n\n4줄의 코드가 1줄이 되었다. 그리고 다른 동작들도 손쉽게 추가할 수 있다. 코드의 양도 줄고 반복도 없어졌으니 좋은건가? 여기서 우리는 이 추상화가 필요한 추상화였는지 생각해볼 필요가 있다. 위 코드를 처음 접하는 개발자는 빠르게 이 코드를 이해할 수 있을까? 나는 추상화를 하기 전 코드가 오히려 흐름을 파악하기 쉽고 직관적이라고 생각한다.\n\n- Conciseness . 간결함\n- Conciseness level . 의미 있는 단위의 최소 단위\n\n우리는 코드에서 Conciseness(간결함)를 추구한다. 하지만 짧은 코드를 모두 좋은 코드라고는 볼 수 없다. Conciseness level(의미 있는 단위의 최소 단위) 우리는 이 레벨을 낮춰서 읽기 수월하게 만들어야 한다. 단순히 추상화를 진행한다고 conciseness level이 높은게 아니다. 이 과정은 코드를 단순히 짧게 만드는 것과는 다르다. 추상화 레벨이 높을수록 숨어있는 말과 의미가 많다. 그 숨겨진 의미가 노출되지 않았을 때 실수가 줄고 효율이 높아진다.\n\n그렇다면 나와 같은 프로덕트 개발자는 어디까지 추상화를 진행해야 할까? 서비스 레벨에서는 자신의 코드를 지우거나 변경하기 쉽게 만드는게 최고다. 위에서 만들었던 useHideCallback 같이 프레임워크인척하면 안된다. 이는 오히려 변경하기 어렵게 만든다.\n\n서비스 코드는 쉽게 변경되기 때문에 높은 추상화를 요구하지 않고 대체로 불필요하다. 스펙이 바뀔 가능성이 높기 때문에 변하지 않는다고 단언하는건 위험하다. 이러한 이유로 useHideCallback 수준으로 추상화를 진행하지 않아도 괜찮다. 지금은 hide, onPrevious 두 개의 로직이지만 중간에 로그와 같은 로직들이 추가될 가능성이 높기 때문이다.\n\n반대로 프레임워크 수준은 단언할 수 있어야할 만큼 안정적이고 더 이상 변경될 요지가 없을 만큼 성숙해져야 한다. (e.g., useState, useCallback)\n\n---\n\n지금부터는 한 줄씩 짧게 끊어서 글을 이어가려고 한다. 각 줄에 대한 설명을 적을 수도 있었지만 대부분 충분히 전달력 있는 문장이라고 생각했기 때문이다.\n\n## 2. 코드에 접근하는 방식\n\nTop-down 방식으로 숲을 먼저 본 다음 나무 각각의 관계성을 본다.\n\n정보가 여러 개 있을 때는 추상화를 진행하며, 의존성을 낮춘다.\n\n소스 코드에 사용하는 변수, 모듈, 함수 등 각각에 대한 책임을 고민한다.\n\n읽기 쉬운 코드가 무엇일까에 대하여 고민한다.\n\n“어떻게”보다는 “무엇\"에 더 집중해야 한다.\n\n- 개발뿐만 아니라 설명할 때도 동일하다. 어떤 문제가 있느냐를 생각하고 전달하자.\n- 무엇과 어떻게가 비슷하다면 어떻게로 진행한다. (추상화를 진행하여도 수준이 비슷하다면 꼭 추상화를 할 필요는 없다.)\n\n이미 사용된 솔루션을 존중할 수 있지만, 무조건 신뢰해서는 안 된다.\n\n- “예전에도 이랬으니까 이번에도 이렇다\"라는 근거는 합리적이지 않다.\n\n실수할 여지가 있는 코드는 피한다.\n\n서비스 간 패키지를 공유하는 것은 패키지 간의 의존성이 생기기 때문에 좋지 않다.\n\n완전히 종속된 컴포넌트는 파일을 더 만드는 것이 아닌 한 파일 안에서 작성하는 것도 좋다.\n\n가능한 입력 범위를 예상하고, 그에 따라 적절한 솔루션을 적용하자\n\n동작 원리를 이해할 수 있어야 한다.\n\n코드를 통제할 수 있어야 한다.\n\n작은 부분에 대하여 스스로 확답이 있어야 한다.\n\n코드가 더럽다고 느껴질 때\n\n- 하나의 함수에서 순서를 정리해보거나 주석, 별도 함수로 나눠보자\n- 줄일 수 있는 조건문을 찾아보자 (중복, 불필요한 반복)\n- 상태를 관리하는 변수가 많은지 찾아보고 리팩토링해보자\n- 전체적인 코드 정리 및 리팩토링에 들어가자\n- 네이밍을 신경 쓰자\n- inline 할 수 있는 함수가 있는가 살펴보자\n\n코드에 대한 고민\n\n- 다음에 이 코드를 봤을 때 더 빨리 읽고 수정이 가능해야 한다.\n\n---\n\n## 3. 문제 해결에 대한 방식\n\n큰 문제를 작은 문제로 쪼개서 풀 수 있는 문제로 만들자\n\n시스템 퍼포먼스의 비용보다 사람 리소스의 비용이 더 크다.\n\n개발을 진행하다 막히는 부분이 있으면, 혼자 해결할 수 있는 문제인지 아닌지 먼저 파악한다. (네이티브, 서버의 도움이 필요한가)\n\n무작정 기능 구현에 집중하기보다는 해당 기능의 임팩트와 들어가는 비용을 생각하며 일을 정한다.\n\n요구사항, 블로킹 정도, 일정에 따라 빠르게 우선순위가 바뀐다.\n\n적극적으로 의견을 피력하는게 중요하다.\n\n판단은 논리적인 근거가 필요하다.\n\n더 나은 엔지니어링 솔루션이 있는지 탐색하고 비교한다.\n\n논리에 허점이 있을 때 인정하고 시스템 논리에 솔직해지자\n\n이전에 대화했던 의견에 대하여 확신이 들지 않을 때 이전의 히스토리를 먼저 설명한다.\n\n- 정보의 불확실성을 공유하는 것이기 때문에 첨언을 하여 상대방에게 먼저 인지를 할 수 있도록 한다.\n\n비즈니스 문제를 엔지니어링 문제로 바꿔보자\n\n운영으로 풀 수 있는걸 테크로 풀지 마라\n\n진행하기 전 블로커를 먼저 찾고 흐름을 파악하자\n"},"__N_SSG":true},"page":"/posts/[category]/[slug]","query":{"category":"essay","slug":"development-journal"},"buildId":"rGSduaPge73_pVAo9USSe","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>