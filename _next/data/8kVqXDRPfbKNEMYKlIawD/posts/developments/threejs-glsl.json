{"pageProps":{"frontmatter":{"title":"Nextjs & Threejs & GLSL를 시작하며 WIP","date":"2023-08-06"},"content":"\n대학생 시절 나는 [awwwards](https://www.awwwards.com/)를 보며 화려한 인터랙션에 빠졌고, 그 중 Threejs, GLSL로 만든 웹사이트를 보며 이게 Javascript로 만들 수 있는 효과들인지 생각하곤 했다. 직접 만들어보고 싶었지만 Javascript로 겨우 Dom을 조작하는게 전부였던 나에게는 역시 무리였다. 졸업을 하고 첫 회사를 다닐때쯤 우연히 [유튜브 영상](https://www.youtube.com/watch?v=DdQn82X1G3I&list=WL&index=26) 하나가 눈에 들어왔다. 그 영상은 평소 해보고싶었던 인터랙션 중 하나였기에 들뜬 마음으로 보았지만 이해가 가지 않았다. 마음 한켠에 언젠가 꼭 만들고 싶다는 다짐을 하고 시간은 그렇게 2년이 지났다. 영상을 최근에서야 다시 보았는데 지금 보니 조금만 공부한다면 그리 어려울 것 같지는 않았다. 더 이상 미룰 수 없다. 항상 마음의 짐이였던 GLSL. 이제는 직접 만들어보자.\n\n## Step . 0\n\n큰 문제를 작은 문제를 쪼개서 접근해겠다.\n\n1. 마크업을 진행한다.\n2. 관성 스크롤을 만든다.\n3. Threejs를 활용하여 이미지들을 canvas에 그린다.\n4. 쉐이더를 적용한다.\n\n## Step . 1\n\n원하는 마크업을 완료하였으면 관성 스크롤을 만들어야한다.  \n원리는 간단하다. 마크업했던 Dom을 div로 감싸고 `position: fixed;` 로 화면을 고정시킨다. 이러면 스크롤을 하여도 유저는 상단 부분만 보게된다.\n\n```html\n<div css={{position: 'fixed' }} className=\"scrollable\">\n  <img src=\"./foo.jpg\" alt=\"\" />\n  <div>Lorem ipsum dolor sit amet.</div>\n  <img src=\"./bar.jpg\" alt=\"\" />\n</div>\n```\n\ntranslate3d() y값을 [lerp()](https://docs.unity3d.com/ScriptReference/Vector3.Lerp.html)로 제어하여 스크롤이 부드럽게 되도록 만들어야한다. `requestAnimationFrame`과 함께 사용하면 스크롤과 콘텐츠의 y값을 매 프레임마다 변경시킬 수 있다.\n\n```ts\nlet currentScroll = 0; // 현재 유저가 보게되는 스크롤 위치\nlet targetScroll = 0; // 실제 스크롤 위치\nlet ease = 0.1;\nconst scrollable = document.querySelector(`.scrollable`) as HTMLDivElement;\n\nfunction lerp(start: number, end: number, time: number) {\n  return start * (1 - time) + end * time;\n}\n\nfunction setSmoothScroll() {\n  targetScroll = window.scrollY;\n  currentScroll = lerp(currentScroll, targetScroll, effectEase);\n  scrollable.style.transform = `translate3d(0,${-currentScroll}px,0)`;\n}\n```\n\n## Step . 2\n\n이 글은 Threejs 기초 관련 글이 아니기 때문에 구현하고자하는 인터랙션과 관련된 내용에만 집중하겠다. 우선 scene, camera, renderer를 설정한다.\n\n```ts\nconst perspective = 1000;\nconst fov = (180 * (2 * Math.atan(window.innerHeight / 2 / perspective))) / Math.PI;\nconst scene = new THREE.Scene();\nconst camera = new THREE.PerspectiveCamera(fov, getViewport().aspectRatio, 1, 1000);\nconst renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n```\n\nDom에 있는 이미지는 `visibility: hidden;`으로 처리하고 이미지들의 위치와 크기만 가져와서 canvas에 렌더링해야한다. 아래 함수를 사용하여 렌더링할 Plane의 위치와 크기를 설정한건데, position을 구하는 방법이 헷갈릴 수 있으니 좌표 얘기를 살짝하겠다.\n\n웹에서 Dom의 좌표는 좌상단 0, 0 이지만, Threejs에서는 3D좌표계의 중앙이 (0, 0, 0)이다. 중앙에서 위로가면 y는 +되고 아래로 가면 -된다. x는 중앙에서 우측으로 가면 +되고 좌측으로 가면 -된다. getElementDimensions 함수가 하고자 하는 것은 화면의 중심에서 이미지가 얼마나 떨어져있는지를 구하는 것이다. 그림으로 직접 그리면 더 빠르게 이해할 수 있을 것이다.\n\n```ts\nfunction getElementDimensions(element: HTMLElement) {\n  const { width, height, top, left } = element.getBoundingClientRect();\n  const scale = new THREE.Vector2(width, height);\n  const position = new THREE.Vector2(\n    left - window.innerWidth / 2 + width / 2,\n    -top + window.innerHeight / 2 - height / 2\n  );\n  return { scale, position };\n}\n```\n\n위치와 크기를 구했으면 오브젝트를 만들고 scene에 렌더링하면 된다.\n\n```ts\nconst img = document.querySelector('.your-img');\n\nfunction createMeshImage(element: HTMLImageElement) {\n  const geometry = new THREE.PlaneGeometry(1, 1, 10, 10);\n  const texture = new THREE.TextureLoader().load(element.src);\n  const uniforms = {\n    uTexture: { value: texture },\n    uOffset: { value: new THREE.Vector2(0, 0) },\n    uAlpha: { value: 1 },\n  };\n  const material = new THREE.ShaderMaterial({\n    uniforms,\n    fragmentShader,\n    vertexShader,\n    transparent: true,\n  });\n  const mesh = new THREE.Mesh(geometry, material);\n\n  const { position, scale } = getElementDimensions(element);\n  mesh.position.set(0, position.y, 0);\n  mesh.scale.set(scale.x, scale.y, 1);\n\n  function updateMeshStatus(targetScroll: number, currentScroll: number) {\n    const { position, scale } = getElementDimensions(element);\n    mesh.position.set(0, position.y, 0);\n    mesh.scale.set(scale.x, scale.y, 1);\n    uniforms.uOffset.value.set(0, -(targetScroll - currentScroll) * 0.0003);\n  }\n  return { mesh, updateMeshStatus };\n}\n\nscene.add(createMeshImage(img).mesh);\n```\n\n쉐이더는 다음 스텝에서 설명하겠다.\n\n## Step . 3 WIP\n\n### GLSL (OpenGL Shading Language)\n\nC언어를 기초로 한, 상위 레벨의 셰이딩 언어\n\n- vertexShader: 위치 기반 쉐이더\n\n  - `gl_Position`은 항상 존재해야하고 필요하다. 화면의 모든 좌표의 위치를 포함하고 있다.\n  - vec4(x, y, z, w = 1.0)을 넣는다.\n  - projectionMatrix는 좌표를 클릭 공간 좌표로 반환한다. (mat(matrix)4 || vec4)\n  - modelMatrix는 'Mesh'를 기준으로 변환을 적용한다. mat(matrix)4 || vec4\n  - viewMatrix는 카메라를 기준으로 변환을 적용한다.\n    projectionMatrix, modelViewMatrix의 타입은\n\n- fragmentShader: 색상 기반 쉐이더\n  `gl_Fragcolor`는 항상 존재해야하고 필요하다. 모든 좌표의 색상값을 가지고 있다.\n  vec4(r, g, b, a)를 넣는다.\n\n- uniform\n\nCPU위의 프로그램에서 GPU위의 shader로 전달하는 다른 방법\nuniform은 global 이다. global uniform은 shader program 객체에서 고유한 변수이고 shader program의 모든 단계의 모든 shader에서 접근 가능하다. uniform 변수에 어떤 값을 설정, 리셋, 업데이트 하기 전까지 그 값을 계속 유지하고있다.\n\n**varying**: varying은 vertex shader와 fragment shader 간의 데이터 전달을 위해 사용되는 키워드입니다. vertex shader에서 계산된 값들은 varying으로 선언된 변수에 저장되며, 이 값들은 fragment shader로 보내져 픽셀마다 보간(interpolation)됩니다. 이로 인해 원활한 쉐이딩 및 색상 전환 효과를 얻을 수 있습니다. 예를 들어, vUv 같은\n변수는 vertex shader에서 계산된 텍스처 좌표가 fragment shader로 보내져서 각 픽셀에 텍스처를 매끄럽게 적용할 수 있게 됩니다.\n\n**sampler2D**: sampler2D는 2D 텍스처 데이터를 읽어오기 위해 사용되는 타입입니다. fragment shader 내에서 텍스처 데이터에 접근하고 처리하기 위해 사용됩니다. sampler2D 타입의 변수는 텍스처 데이터를 읽는 데 사용되며, 이를 통해 텍스처 이미지를 쉐이더 내에서 사용할 수 있습니다. uniform sampler2D myTexture;와 같이 선언한 후, texture2D(myTexture, uv)와 같이 사용하여 텍스처 데이터를 읽어올 수 있습니다.\n\n**uv**: 2D 텍스처 좌표입니다. 일반적으로 0부터 1까지의 값으로 텍스처 이미지를 가져올 때 어느 부분을 사용할지 지정합니다.\n\n**vUv**: Three.js의 쉐이더에서 전달되는 변수로, vertex shader에서 fragment shader로 전달되는 텍스처 좌표입니다. 일반적으로 varying 변수로 선언되며, vertex shader에서 계산된 값을 fragment shader로 전달하여 각 픽셀에 텍스처를 적용할 때 사용됩니다.\n\n**texture2D()**: texture2D()는 텍스처 샘플링을 수행하는 함수입니다. 주어진 텍스처와 좌표에 따라 텍스처 이미지의 픽셀 값을 가져올 수 있습니다. 예를 들어 texture2D(texture, uv)는 특정 텍스처에서 uv 좌표 위치의 픽셀 값을 가져옵니다.\n\n**projectionMatrix**: 3D 공간의 좌표를 2D 화면 좌표로 변환하는 데 사용됩니다. 카메라의 시야각, 종횡비 등을 고려하여 설정됩니다.\n\n**modelViewMatrix**: 모델의 위치, 회전 및 크기 변환을 나타내며, 모델 좌표를 카메라의 뷰 좌표로 변환합니다. 모델뷰 행렬은 보통 카메라의 뷰 행렬과 모델의 변환 행렬을 곱한 것으로 계산됩니다.\n"},"__N_SSG":true}